---

## 说明（如何使用这份清单）

* 按任务编号顺序执行（从 T01 开始）。每个任务独立、最小可交付。
* **开始条件**：仓库存在、分支为 `mvp/TXX`（或由 LLM 创建）。
* **结束条件**：通过验收标准（测试/手动检查）并合并到 `develop`（或主分支）。
* 不要跳过依赖任务（每个任务列出了前置依赖）。

---

# 任务列表（按顺序）

### T01 — 初始化仓库与基础工程配置

* **目标**：创建 Next.js + TypeScript + Tailwind + Prisma 项目基础结构，验证能运行开发服务器。
* **文件/路径**：根目录（`package.json`、`next.config.ts`、`tsconfig.json`、`tailwind.config.cjs`、`.gitignore`）
* **开始条件**：干净目录 / 新仓库。
* **结束条件**：`pnpm dev`（或 `npm run dev`）能启动并在 `http://localhost:3000` 返回 200。
* **步骤**:

  1. `npx create-next-app@latest --experimental-app --typescript`（或模板）初始化。
  2. 安装 Tailwind CSS 4、shadcn/ui（基础依赖）、prisma、@prisma/client、bytemd、swr、better-auth（占位）。
  3. 添加基础 `app/layout.tsx` 和 `app/page.tsx`（简单欢迎页）。
  4. 配置 Tailwind（`globals.css` 引入）。
  5. 初始化 git，提交 `T01-init`.
* **验收测试**：

  * 打开 `http://localhost:3000`，页面含 “Welcome” 文本（手动或自动化 HTTP GET）。
  * `pnpm prisma -v` 有响应（prisma 安装验证）。
* **依赖**：无
* **回滚**：重置到上一次 commit。

---

### T02 — 配置 Prisma + SQLite 基本模型并能迁移

* **目标**：添加 Prisma schema、生成客户端，能成功运行 `prisma migrate dev` 并看到 `dev.db`。
* **文件/路径**：`prisma/schema.prisma`、`lib/prisma.ts`
* **开始条件**：T01 完成。
* **结束条件**：数据库文件 `prisma/dev.db` 存在，`lib/prisma.ts` 导出 `prisma` 单例。
* **步骤**:

  1. 写入 `schema.prisma`：定义 `User`, `Blog`, `Category`, `Tag`, `Session`, `Account`（保留最小字段）。
  2. 运行 `npx prisma migrate dev --name init`.
  3. 在 `lib/prisma.ts` 导出单例 `PrismaClient`（避免多实例）。
* **验收测试**：

  * `node -e "require('./lib/prisma').prisma"` 不报错（或在 ts-node 环境）。
  * `sqlite3 prisma/dev.db` 能打开并 `SELECT name FROM sqlite_master WHERE type='table';` 返回表名（脚本化检查）。
* **依赖**：T01
* **回滚**：删除 `prisma/dev.db` 和迁移文件，恢复 schema。

---

### T03 — 基础 auth 后端 stub（better-auth 占位实现）

* **目标**：在 `app/api/auth/[...all]/route.ts` 放置认证路由占位，能返回 200 并能读取 cookie header（用于后续替换为 better-auth）。
* **文件/路径**：`app/api/auth/[...all]/route.ts`、`lib/auth.ts`
* **开始条件**：T02 完成。
* **结束条件**：对 `POST /api/auth/health` 返回 `{ ok: true }`。
* **步骤**:

  1. 创建 `route.ts`，实现简单 GET/POST 处理，返回 JSON。
  2. 在 `lib/auth.ts` 创建 `auth.api.getSession` stub（返回 `null`）。
* **验收测试**：

  * HTTP GET `/api/auth/health` 返回 200 + `{ ok: true }`。
* **依赖**：T02
* **回滚**：还原 `route.ts` 到先前状态。

---

### T04 — 基本 API 路由：博客列表（GET）与创建（POST）最小实现

* **目标**：实现 `app/api/blogs/route.ts`，支持 `GET`（分页）和 `POST`（创建），并使用 Prisma 写/读 `Blog`。
* **文件/路径**：`app/api/blogs/route.ts`
* **开始条件**：T02、T03。
* **结束条件**：能通过 API 创建一条 blog 并在 GET 返回。
* **步骤**:

  1. 实现 `GET`：支持查询参数 `page`, `pageSize`，返回 `{ data, total }`。
  2. 实现 `POST`：验证必需字段 `title, body`, 使用 prisma.create。
  3. 返回标准化 JSON `{ data, error? }`。
* **验收测试**：

  * 使用脚本 `curl -X POST /api/blogs -d '{"title":"t","body":"b"}'` 返回 201 和新记录 id。
  * `GET /api/blogs` 包含刚创建项。
* **依赖**：T02, T03
* **回滚**：撤销 route 文件改动与 DB 插入（手动删除）。

---

### T05 — 前端：博客列表页面（SSR）和 Server Component 获取数据

* **目标**：实现 `app/(root)/blogs/page.tsx`，使用 Server Component 在服务端查询博客并渲染列表（SSR）。
* **文件/路径**：`app/(root)/blogs/page.tsx`、`lib/prisma.ts`（已存在）
* **开始条件**：T04
* **结束条件**：访问 `/blogs` 能看到从数据库拉取的列表（服务端渲染）。
* **步骤**:

  1. 新建 Server Component `page.tsx`，在 `getServerSideProps` 等价位置直接使用 `prisma.blog.findMany`.
  2. 渲染标题与摘要。
* **验收测试**：

  * 页面 HTML（源代码）包含数据库中博客标题（验证 SSR）。
* **依赖**：T04
* **回滚**：还原页面文件。

---

### T06 — 后台：Admin 验证中间件（noAdminPermission stub）与 admin layout

* **目标**：实现 `noAdminPermission()` 服务端函数（调用 `auth.api.getSession`），并添加 `app/admin/layout.tsx` 能阻止未授权访问（暂时返回 401）。
* **文件/路径**：`app/admin/layout.tsx`、`app/actions.ts`、`lib/auth.ts`
* **开始条件**：T03、T05
* **结束条件**：访问 `/admin` 在未登录时返回 401（或显示“无权限”）。
* **步骤**:

  1. 在 `app/actions.ts` 添加 `noAdminPermission()` 使用 `auth.api.getSession`.
  2. `app/admin/layout.tsx` 在服务端检查并根据结果显示“无权限”或 `children`.
* **验收测试**：

  * 未登录时访问 `/admin` 返回 401（页面或响应）。
* **依赖**：T03、T05
* **回滚**：移除检查。

---

### T07 — 后台：博客创建表单（客户端）+ SWR mutation hook

* **目标**：在 `app/admin/blog/create/page.tsx` 提供博客创建表单（使用 react-hook-form + bytemd stub），并通过 `useCreateBlog`（SWR mutation）调用 `/api/blogs`.
* **文件/路径**：`app/admin/blog/create/page.tsx`、`app/admin/blog/api.ts`（前端 API helper）、`hooks/useCreateBlog.ts`
* **开始条件**：T06、T04、T05
* **结束条件**：在 admin 页面提交表单可在数据库生成 blog。
* **步骤**:

  1. 实现简单表单（title、body textarea 或 bytemd 编辑器的 placeholder）。
  2. 实现 `api.ts` 的 `createBlog()` 使用 `fetch('/api/blogs', { method: 'POST' })`.
  3. 实现 `useCreateBlog` 包装 SWR 的 `mutate`/`trigger`.
* **验收测试**：

  * 填表提交后，数据库出现新条目且前端收到成功响应（可用 UI 通知）。
* **依赖**：T04, T06
* **回滚**：删除创建页面改动并删除数据库条目。

---

### T08 — API：单篇 Blog 的 GET/PUT/DELETE 路由

* **目标**：实现 `app/api/blog/[id]/route.ts`，支持 GET（单篇）、PUT（编辑）、DELETE（删除），包含基本权限检查（PUT/DELETE 需 admin）。
* **文件/路径**：`app/api/blog/[id]/route.ts`
* **开始条件**：T04, T06
* **结束条件**：能通过 API 编辑并删除 blog（权限要求生效）。
* **步骤**:

  1. 实现 `GET`：`prisma.blog.findUnique({ where: { id } })`.
  2. 实现 `PUT`：验证字段，权限检查，`prisma.blog.update`.
  3. 实现 `DELETE`：权限检查，`prisma.blog.delete`.
* **验收测试**：

  * `GET /api/blog/{id}` 返回 blog。
  * 非 admin 访问 `PUT`/`DELETE` 返回 401；admin 返回成功。
* **依赖**：T04、T06
* **回滚**：恢复此 route 文件。

---

### T09 — 前端：博客详情页（动态路由 SSR）与编辑入口

* **目标**：实现 `app/(root)/blog/[slug]/page.tsx` SSR 渲染详情，并在 admin 后台列表中为每篇 blog 添加 “编辑” 链接。
* **文件/路径**：`app/(root)/blog/[slug]/page.tsx`、`app/admin/blog/page.tsx`（管理列表）
* **开始条件**：T05、T08、T07
* **结束条件**：访问 `/blog/{slug}` 能看到 blog 内容；后台列表包含编辑链接。
* **步骤**:

  1. Server Component 获取 blog by slug 并渲染。
  2. Admin 列表添加编辑按钮链接到 `admin/blog/edit/[id]`.
* **验收测试**：

  * 页面源代码含 blog 正文（SSR）。
  * 管理列表的编辑链接可打开编辑表单（编辑表单由下一个任务完善）。
* **依赖**：T05, T08
* **回滚**：还原页面与 admin 列表改动。

---

### T10 — 后台：博客编辑页（PUT）与表单预填充

* **目标**：实现 `app/admin/blog/edit/[id]/page.tsx`，预填充表单并能提交编辑（调用 `PUT /api/blog/{id}`）。
* **文件/路径**：`app/admin/blog/edit/[id]/page.tsx`
* **开始条件**：T08、T07、T09
* **结束条件**：编辑保存后数据在数据库更新，页面显示成功反馈。
* **步骤**:

  1. 根据 id 获取 blog（可以在客户端调用 GET API）。
  2. 使用 react-hook-form 预填充。
  3. 提交触发 `PUT /api/blog/{id}`。
* **验收测试**：

  * 修改标题/内容后，`GET` 再次查询显示更新后的值。
* **依赖**：T08、T07、T09
* **回滚**：还原编辑页并回滚 DB 变更（手动）。

---

### T11 — 数据模型扩展：Category 与 Tag CRUD（API + Admin UI）

* **目标**：实现 `Category` 和 `Tag` 模型的 API（GET/POST/PUT/DELETE）与 Admin 管理界面（简单列表 + 创建）。
* **文件/路径**：`prisma/schema.prisma`（若需字段调整）、`app/api/categories/*`、`app/api/tags/*`、`app/admin/category/*`、`app/admin/tag/*`
* **开始条件**：T02，T04，T06
* **结束条件**：能在 admin 创建/列出/删除分类与标签，并关联博客（关联 UI 在下一个任务）。
* **步骤**:

  1. 添加 API routes（CRUD）。
  2. 添加 admin 页面：list + create。
* **验收测试**：

  * `POST /api/categories` 成功，`GET /api/categories` 返回包含创建项。
  * Admin UI 能列出并删除。
* **依赖**：T02、T04、T06
* **回滚**：删除新增路由与 UI。

---

### T12 — 为 Blog 添加 Category/Tags 字段、并在创建/编辑时支持关联

* **目标**：在创建/编辑博客时允许选择 Category 与多个 Tags（通过 id 列表），后端接受并保存关联。
* **文件/路径**：`app/api/blogs/route.ts`（POST）、`app/api/blog/[id]/route.ts`（PUT）、`app/admin/blog/create/page.tsx`、`app/admin/blog/edit/[id]/page.tsx`
* **开始条件**：T11、T07、T10
* **结束条件**：创建/编辑 blog 时能设置 category 和 tags，并在详情页显示关联信息。
* **步骤**:

  1. 前端在表单中加入 category select、tags multiselect（数据从 API 拉取）。
  2. 后端在 create/update 使用 prisma 关联（connect）。
* **验收测试**：

  * 创建时提交 categoryId + tagIds，`GET /api/blogs`/详情显示关联名称。
* **依赖**：T11、T07、T10
* **回滚**：还原表单与 API 修改。

---

### T13 — 前端：Bytemd 编辑器完整集成（保存富文本/Markdown）

* **目标**：把 bytemd 编辑器集成到 create/edit 表单，提交 Markdown 内容并在详情页正确渲染（可以用 simple markdown renderer）。
* **文件/路径**：`components/bytemd/*`、`app/admin/blog/create/page.tsx`、`app/admin/blog/edit/[id]/page.tsx`、`app/(root)/blog/[slug]/page.tsx`
* **开始条件**：T12
* **结束条件**：在 admin 编辑器输入 Markdown，保存后详情页显示格式化文本（例如 h1、列表、代码块）。
* **步骤**:

  1. 创建 `components/bytemd/Editor.tsx` 封装。
  2. 替换表单的 textarea 为 Editor。
  3. 详情页使用 `react-markdown`（或自带 bytemd viewer）渲染。
* **验收测试**：

  * 创建一篇包含标题和列表的 Markdown，详情页渲染出相应标签。
* **依赖**：T12
* **回滚**：还原表单到 textarea。

---

### T14 — 客户端缓存：实现 SWR hooks（useGetBlogs, useGetBlog, useCreateBlog, useUpdateBlog）

* **目标**：把常用 API 封装成可复用的 SWR hooks，并在前端页面中替换原始 fetch。
* **文件/路径**：`hooks/useGetBlogs.ts`、`hooks/useGetBlog.ts`、`hooks/useCreateBlog.ts`、`hooks/useUpdateBlog.ts`
* **开始条件**：T04、T07、T08、T09、T10
* **结束条件**：前端所有页面使用 hooks 拉取/提交数据，且 SWR cache 能正确更新（乐观更新测试）。
* **步骤**:

  1. 为每个 API 写 hook（`swr` + `swr/mutation`）。
  2. 在对应页面替换旧调用并验证。
* **验收测试**：

  * 在创建 blog 后，blog 列表自动刷新包含新条目（SWR revalidation 或 mutate）。
* **依赖**：T04、T07、T08 等
* **回滚**：还原至原始 fetch。

---

### T15 — 前台：分类与标签页面（列表与基于分类/标签的过滤）

* **目标**：实现 `app/(root)/categories/page.tsx`、`app/(root)/category/[slug]/page.tsx`、`app/(root)/tags/page.tsx` 与 `tag/[slug]`，支持按分类/标签查看文章。
* **文件/路径**：上面所列路径
* **开始条件**：T11、T05、T09
* **结束条件**：访问分类/标签页列出归属文章。
* **步骤**:

  1. Server Component 获取分类/标签与关联文章并渲染。
* **验收测试**：

  * 打开 `/category/{slug}` 显示对应文章列表。
* **依赖**：T11、T05、T09
* **回滚**：移除路由改动。

---

### T16 — 搜索 API 与前端简单搜索组件

* **目标**：实现 `GET /api/blogs?query=...` 的后端全文简单搜索（title/description/body 简单 LIKE），并在前台添加一个搜索框组件（按键触发）。
* **文件/路径**：`app/api/blogs/route.ts`（扩展 GET）、`components/navbar/Search.tsx`
* **开始条件**：T04、T05
* **结束条件**：搜索返回匹配 blog 并列表展示。
* **步骤**:

  1. 后端 GET 接受 `query` 参数并使用 prisma 的 `contains` 执行搜索。
  2. 前端 navbar 搜索框调用该 API 并在 `/blogs?query=...` 显示结果。
* **验收测试**：

  * 输入词条能返回包含该词的文章（自动测试脚本可对 API 发请求验证）。
* **依赖**：T04、T05
* **回滚**：还原 API 改动。

---

### T17 — 站点信息与常量管理（info.ts / path.ts）

* **目标**：实现 `constants/info.ts` 与 `constants/path.ts`，并在布局中引用站点名称、邮箱等配置（使配置集中）。
* **文件/路径**：`constants/info.ts`、`constants/path.ts`、`app/layout.tsx`、`components/navbar/*`
* **开始条件**：T01
* **结束条件**：布局与页脚均从 constants 加载站点信息。
* **步骤**:

  1. 创建 constants 文件并替换硬编码文本。
* **验收测试**：

  * 修改 constants 中站点名，页面显示更新（重启后）。
* **依赖**：T01
* **回滚**：还原硬编码文本。

---

### T18 — 全局样式与暗黑模式切换（next-themes）

* **目标**：集成 `next-themes` 提供暗/亮模式切换，并保证 Tailwind 的样式配合生效。
* **文件/路径**：`components/providers/ThemeProvider.tsx`、`app/layout.tsx`
* **开始条件**：T01、T05
* **结束条件**：页面上有切换按钮，切换能切换主题并持久化（localStorage）。
* **步骤**:

  1. 安装 `next-themes` 并在 provider 包装 root layout。
  2. 添加 UI 控件切换主题。
* **验收测试**：

  * 切换后页面视觉变化且刷新仍保持所选主题。
* **依赖**：T01, T05
* **回滚**：移除 provider。

---

### T19 — 错误处理/通知系统（pubsub-js 或 toast）

* **目标**：实现统一错误通知机制（前端 toast）：当 API 返回 error，显示可读提示。
* **文件/路径**：`lib/request.ts`（axios fetch wrapper）、`components/ui/Toast.tsx`、`providers/NotificationProvider.tsx`
* **开始条件**：T04、T07
* **结束条件**：任意 API 返回 error 时显示 toast。
* **步骤**:

  1. 封装 `request.ts`，在失败时抛出标准错误对象。
  2. 在 `providers` 中监听错误并触发 `Toast`。
* **验收测试**：

  * 手动调用返回 400 的 API，看到 toast 出现。
* **依赖**：T04、T07
* **回滚**：停用通知组件。

---

### T20 — 本地部署脚本 & README（一键启动）

* **目标**：完成 `README.md` 和 `scripts`（`dev`, `migrate`, `seed`, `start`），确保别人能在本地按文档跑通项目。
* **文件/路径**：`README.md`、`package.json` scripts
* **开始条件**：前面任务完成（T01~T19）
* **结束条件**：按 README 的步骤，工程能从零到运行（本地）。
* **步骤**:

  1. 编写 `README`：依赖、启动步骤、迁移、如何运行测试。
  2. 在 `package.json` 添加脚本别名。
* **验收测试**：

  * 新 clone 一次仓库（或 CI 脚本）按 README 能成功启动（手动或 CI）。
* **依赖**：所有核心功能
* **回滚**：修改 README 不影响代码。

---

### T21 — 基础 E2E / 集成测试（Playwright 或 Cypress）覆盖关键流程

* **目标**：添加一套最小 E2E 测试：访问首页、创建 blog（后台）、查看文章（前台）、编辑文章、删除文章。
* **文件/路径**：`tests/e2e/*`、`package.json` 增加 test 脚本
* **开始条件**：T20
* **结束条件**：在 CI 或本地运行 `pnpm test:e2e`，所有用例通过。
* **步骤**:

  1. 安装 Playwright。
  2. 编写测试脚本覆盖核心场景。
* **验收测试**：

  * 运行测试脚本返回全部通过。
* **依赖**：T20
* **回滚**：删除 tests 目录（若失败）。

---

### T22 — 可选：部署到云（演示环境）

* **目标**：提供一个最小部署方案（Vercel / Railway / Docker Compose），并把 `DATABASE_URL` 指向云或内置 SQLite（注意 Vercel 不推荐 SQLite）。
* **文件/路径**：`Dockerfile`、`docker-compose.yml` 或 `vercel.json`、部署说明
* **开始条件**：T20、T21
* **结束条件**：线上 demo 可访问（若选择）。
* **步骤**:

  1. 选择部署平台并创建配置。
  2. 配置 ENV（DATABASE_URL、NEXT_PUBLIC_BASE）。
* **验收测试**：

  * 线上 URL 能打开并展示首页。
* **依赖**：T20
* **回滚**：撤销部署。

---

# 最后一部分：每个任务的“验收用例（简版）”模板

把下面模板放给执行该任务的工程 LLM，让它在完成后返回填好的验收表格。

```
任务：TXX - 任务标题
开始时间：YYYY-MM-DDTHH:MMZ
结束时间：YYYY-MM-DDTHH:MMZ
变更文件列表：
- path/to/file1
- path/to/file2

自动化测试结果：
- 命令：`...`
- 输出摘要：通过 / 失败（错误日志附后）

手动检查：
- 步骤 1：...
- 结果：通过 / 失败（说明）

回滚步骤（如需要）：
- git revert <commit> 或 删表/删除文件指令
```

---

如果你愿意，我可以把这些任务中的任何一个 **立刻** 展开成更详细的子步骤（例如 T04 的 POST/GET 具体代码模板 + Zod 验证 schema + 单元测试脚本），直接生成可执行的代码补丁。你想让我现在把哪个任务拆成“工程 LLM 可直接执行”的具体指令？
